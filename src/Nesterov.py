# -*- coding: utf-8 -*-
"""
Created on Mon Nov 13 11:14:54 2017

@author: tthiem1

Module for simulation of both the continuous and discrete Nesterov methods.
"""

import numpy as np
from scipy.integrate import ode

def cNesterov(x0, f, df, trange=np.linspace(0, 50)):
    """
    Computes the minimum of f using the continuous Nesterov method.
    
    Parameters
    ==========
    x0 : (np.ndarray) - The inital guess for the minimum.
    f : (function) - The function to be minimized.
    df : (function) - The derivative of the function to be minimized.
    trange : (np.ndarray) - An array of the output times for the integration.
    
    Returns
    =======
    positions : (np.ndarray) - An array of the positions of the independent
    variable at each time point given in trange. Shape (#dimensions, #times).
    velocities : (np.ndarray) - An array of the velocities (first derivative)
    of the independent variable at each time point given in trange. Shape (#dimensions, #times).
    """
    def RHS(t, y):
        """
        RHS function generated by reducing the second order continuous Nesterov
        ODE to a system of two first order ODEs.
        
        t : (float) - The integration time variable.
        y : (np.ndarray) - The independent variable of the function
        to be minimized.
        """
        y1 = y[:int(y.size/2)]
        y2 = y[int(y.size/2):]
        if t == 0:
            t = 0.001
        return np.hstack((y2, -3 * y2 / t - df(y1)))
    
    dxdt0 = np.zeros((x0.size,))
    ODE = ode(RHS)
    ODE.set_integrator('dopri5')
    ODE.set_initial_value(np.hstack((x0, dxdt0)), trange[0])
    positions = np.empty((x0.size, trange.size))
    velocities = np.empty((x0.size, trange.size))
    
    for idx, _t in enumerate(trange[1:]):
        positions[:, idx] = ODE.y[:int(ODE.y.size/2)]
        velocities[:, idx] = ODE.y[int(ODE.y.size/2):]
        ODE.integrate(_t)
    positions[:, -1] = ODE.y[:int(ODE.y.size/2)]
    velocities[:, -1] = ODE.y[int(ODE.y.size/2):]
    
    return (positions, velocities)

def dNesterov(x0, f, df, iters=10, stepsize=1):
    """
    Computes the minimum of f using the discrete Nesterov method. 
    If a gradient is not provided, it will be calculated from f.
    
    Parameters
    ==========
    x0 : (np.ndarray) - The inital guess for the minimum.
    f : (function) - The function to be minimized.
    df : (function) - The derivative of the function to be minimized.
    iters : (int) - The number of iterations to perform.
    stepsize : (float) - The step size used in the Nesterov calculation.

    Returns
    =======
    results : (np.ndarray) - An array of the values of the indepenent variable
    at each iteration step. Shape (#dimensions, #iterations + 1).
    """
    results = np.zeros((np.array(x0).size, iters + 1))
    x, y = x0, x0
    results[:, 0] = x
    
    for i in range(1, iters + 1):
        xnew = y - stepsize * df(y)
        ynew = xnew + ((i - 1)/(i + 2)) * (xnew - x)
        x, y = xnew, ynew
        results[:, i] = x

    return results

if __name__ == '__main__':

    def test1():
        return dNesterov(np.array([1, 1]), lambda x: 0.02 * x[0] ** 2 + 0.005 * x[1] **2,
                         lambda x: np.array([0.04 * x[0], 0.01 * x[1]]), iters=100, stepsize=0.25)
        
    def test2():
        return cNesterov(np.array([1, 1]), lambda x: 0.02 * x[0] ** 2 + 0.005 * x[1] **2,
                         lambda x: np.array([0.04 * x[0], 0.01 * x[1]]))
        
    import matplotlib.pyplot as plt
    plt.scatter(*test1())
    plt.scatter(*test2()[0])
